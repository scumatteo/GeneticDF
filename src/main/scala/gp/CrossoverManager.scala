package gp

import gp.CrossoverType.CrossoverType
import tree.ImprovedExpressionTree.{ImprovedExpressionTree, Node}
import utils.IntUtils

import scala.util.Random

/**
 * Type of crossover. Two different strategies are modeled.
 * In the strategy method 1, two subtrees are switched entirely.
 * In the strategy method 2, two subtrees are switched, but the multiplier factors of the roots are not switched.
 */
object CrossoverType extends Enumeration {
  type CrossoverType = Value
  val STRATEGY_1, STRATEGY_2 = Value
}

/**
 * Object to manage crossover.
 */
object CrossoverManager {

  /**
   * Probability to perform the strategy 1 of crossover.
   */
  val STRATEGY_1_PROBABILITY: Double = 0.6

  //TODO check depth in crossover

  /**
   * Static method to perform crossover between two trees.
   *
   * For each tree, a random depth is chosen, then a random node at this depth is chosen, that is the root of the subtree
   * to cross.
   *
   * @param tree1 the first tree
   * @param tree2 the second tree
   * @return a tuple of two IE-Trees that are the offspring generated by the crossover.
   */
  def performCrossover(tree1: ImprovedExpressionTree, tree2: ImprovedExpressionTree): (ImprovedExpressionTree, ImprovedExpressionTree) = {
    val strategy = CrossoverType(if (Random.nextDouble() < STRATEGY_1_PROBABILITY) 0 else 1)

    val randomDepth1 = IntUtils.getRandomInt(1, tree1.depth())
    val randomDepth2 = IntUtils.getRandomInt(1, tree2.depth())

    val tree1Level = tree1.getNodesAtDepth(randomDepth1)
    val tree2Level = tree2.getNodesAtDepth(randomDepth2)

    val randomSubtree1: ImprovedExpressionTree = tree1Level(Random.nextInt(if(tree1Level.isEmpty) 1 else tree1Level.size))
    val randomSubtree2: ImprovedExpressionTree = tree2Level(Random.nextInt(if(tree2Level.isEmpty) 1 else tree2Level.size))

    (cross(tree1, randomSubtree1, randomSubtree2, strategy), cross(tree2, randomSubtree2, randomSubtree1, strategy))

  }

  /**
   * Private method to perform crossover over a tree, according to the chosen strategy.
   *
   * @param tree the tree to modify.
   * @param mySubtree the subtree of the tree to cross.
   * @param otherSubtree the subtree of the other tree to cross.
   * @param strategy the crossover strategy chosen.
   *
   * @return a new IE-Tree that is the result of the crossover between the two subtrees.
   */
  private def cross(tree: ImprovedExpressionTree,
            mySubtree: ImprovedExpressionTree, otherSubtree: ImprovedExpressionTree, strategy: CrossoverType): ImprovedExpressionTree = tree match {
    case n: Node if n.l == mySubtree =>
      n.replaceChildren(if(strategy == CrossoverType.STRATEGY_1) otherSubtree else otherSubtree.copyWithMP(mySubtree.multiplierFactor), n.r.clone())
    case n: Node if n.r == mySubtree =>
      n.replaceChildren(n.l.clone(), if(strategy == CrossoverType.STRATEGY_1) otherSubtree else otherSubtree.copyWithMP(mySubtree.multiplierFactor))
    case n: Node =>
      n.replaceChildren(cross(n.l, mySubtree, otherSubtree, strategy), cross(n.r, mySubtree, otherSubtree, strategy))
    case _ => tree

  }
}
